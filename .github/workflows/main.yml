name: CI/CD PIPELINE

on:
  push:
    branches: ["terraform_practice"]
  pull_request:
    branches: ["terraform_practice"]

jobs:

  terraform:
    name: 'Terraform'
    env:
      AWS_ACCESS_KEY_ID: ${{secrets.ACCESS_KEY}}
      AWS_SECRET_ACCESS_KEY: ${{secrets.SECRET_KEY}}

    runs-on: ubuntu-22.04
    environment: production

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    steps:
      # Checkout the repository to the GitHub Actions runner
      - name: Checkout
        uses: actions/checkout@v3

      # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
      - name: Terraform Init
        run: terraform init

      # Checks that all Terraform configuration files adhere to a canonical format
      - name: Terraform Format
        run: terraform fmt -check

      # Generates an execution plan for Terraform
      - name: Terraform Plan
        run: terraform plan -input=false

        # On push to "main", build or change infrastructure according to Terraform configuration files
        # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
      - name: Terraform Apply
        if: github.ref == 'refs/heads/terraform_practice' && github.event_name == 'push'
        run: terraform apply -auto-approve -input=false

      - id: step1
        run: echo "test=hello" >> "$GITHUB_OUTPUT"

      - outputs:
        output1: ${{ steps.step1.outputs.instance_ip_addr}}



  # test:
  #   runs-on: ubuntu-22.04

  #   steps:
  #   - name: Checkout code
  #     uses: actions/checkout@v3

  #   - name: Setup JDK 17
  #     uses: actions/setup-java@v3
  #     with:
  #       java-version: '17'
  #       distribution: 'corretto'

  #   - name: Run test using gradle
  #     uses: gradle/gradle-build-action@v2
  #     with:
  #       arguments: test

  build:
    # needs: test
    runs-on: ubuntu-22.04

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Setup JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'corretto'
  
    - name: build shadownJar using gradle
      uses: gradle/gradle-build-action@v2
      with:
        arguments: shadowJar

    - name: Archive shadowJar
      uses: actions/upload-artifact@v3
      with:
        name: esopApp 
        path: build/libs

  deploy:
    needs: [build]
    runs-on: ubuntu-22.04
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Download Artifact
        uses: actions/download-artifact@v3
        with:
          name: esopApp
    
      - name: Transfer artifact to EC2 instance
        env:
          SSH_PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}
          SSH_HOST: ${{ secrets.SSH_HOST }}
          OUTPUT1: ${{needs.job1.outputs.output1}}

        run: |
          eval `ssh-agent`
          echo "sanjeev"
          echo "$OUTPUT1"
          echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add - > /dev/null
          scp -o StrictHostKeyChecking=no "deploy.sh" ec2-user@$SSH_HOST:~
          scp -o StrictHostKeyChecking=no "esop-0.1-all.jar" ec2-user@$SSH_HOST:~
          ssh -o StrictHostKeyChecking=no ec2-user@$SSH_HOST -t "sudo yum install java-17-amazon-corretto-headless -y"
          ssh -o StrictHostKeyChecking=no ec2-user@$SSH_HOST -t "sudo ./deploy.sh"
